// Copyright 2018-present the CoreDHCP Authors. All rights reserved
// This source code is licensed under the MIT license found in the
// LICENSE file in the root directory of this source tree.

package transient

import (
	"errors"
	"net"
	"sync/atomic"
	"testing"
	"time"

	"github.com/coredhcp/coredhcp/plugins"
	"github.com/coredhcp/coredhcp/plugins/leasestorage"
)

var testCID = leasestorage.ClientIDFromHWAddr(net.HardwareAddr{0x00, 0x11, 0x22, 0x33, 0x44, 0x55})

// creates a LeaseStore, without running the background tasks
func newLeaseStoreForTests() *LeaseStore {
	return &LeaseStore{
		records:    make(map[leasestorage.ClientID]*storage),
		currentRev: 1,
	}
}

func TestLookupEmpty(t *testing.T) {
	ls := newLeaseStoreForTests()

	leases, token, err := ls.Lookup(testCID)
	if err != nil {
		t.Fatalf("Got error when looking up client in empty map: %v", err)
	}

	if !token.Valid() || !token.IsOwnedBy(ls) {
		t.Fatalf("Plugin minted invalid token: %x", token)
	}

	if len(leases) > 0 {
		t.Fatalf("Returned leases when there should be none")
	}
}

func TestAddLease(t *testing.T) {
	ls := newLeaseStoreForTests()
	testClientPlugin := plugins.Plugin{}

	leases, token, err := ls.Lookup(testCID)
	if err != nil || len(leases) > 0 {
		t.Fatalf("Got bad leases (%v): %v", leases, err)
	}

	assignedNet := net.IPNet{
		IP:   net.ParseIP("2001:db8::1"),
		Mask: net.CIDRMask(128, 128),
	}

	toInsert := []leasestorage.Lease{{
		Elements: []net.IPNet{assignedNet},
		// Expire at 0 time
		Owner:        &testClientPlugin,
		ExpireAction: func(elements []net.IPNet, expiredAt time.Time) {},
	}}

	err = ls.Update(testCID, toInsert, token)
	if err != nil {
		t.Fatalf("Could not update lease: %v", err)
	}

	// Second attempt at update with the same token should fail
	err = ls.Update(testCID, toInsert, token)
	if !errors.Is(err, leasestorage.ErrToken) {
		t.Fatalf("Could update the same leases without reobtaining a token")
	}

	// Check the storage is in the expected state:
	all := ls.Dump()

	if all[testCID][0].Owner != &testClientPlugin ||
		!all[testCID][0].Elements[0].IP.Equal(assignedNet.IP) {

		t.Fatalf("Found the following leases: \n %#v", all)
	}

}

func TestConcurrentAddFirstLease(t *testing.T) {
	ls := newLeaseStoreForTests()
	testClientPlugin := plugins.Plugin{}

	leases, token, err := ls.Lookup(testCID)
	if err != nil || len(leases) > 0 {
		t.Fatalf("Got bad leases (%v): %v", leases, err)
	}

	secondLease, secondToken, err := ls.Lookup(testCID)
	if err != nil || len(secondLease) > 0 {
		t.Fatalf("Got bad leases (%v): %v", leases, err)
	}

	assignedNet := net.IPNet{
		IP:   net.ParseIP("2001:db8::1"),
		Mask: net.CIDRMask(128, 128),
	}

	toInsert := []leasestorage.Lease{{
		Elements: []net.IPNet{assignedNet},
		// Expire at 0 time
		Owner:        &testClientPlugin,
		ExpireAction: func(elements []net.IPNet, expiredAt time.Time) {},
	}}

	err = ls.Update(testCID, toInsert, token)
	if err != nil {
		t.Fatalf("Could not update lease: %v", err)
	}

	// secondToken should be invalidated by the concurrent update
	err = ls.Update(testCID, toInsert, secondToken)
	if !errors.Is(err, leasestorage.ErrToken) {
		t.Fatalf("Could update the same leases with an outdated token")
	}
}

func TestModifyLease(t *testing.T) {
	ls := newLeaseStoreForTests()

	leases, token, err := ls.Lookup(testCID)
	if err != nil || len(leases) > 0 {
		t.Fatalf("Got bad leases (%v): %v", leases, err)
	}

	assignedNet := []net.IPNet{{
		IP:   net.ParseIP("2001:db8::1"),
		Mask: net.CIDRMask(128, 128),
	}}

	toInsert := []leasestorage.Lease{{
		Elements: assignedNet,
	}}

	err = ls.Update(testCID, toInsert, token)
	if err != nil {
		t.Fatalf("Could not create lease: %v", err)
	}

	leases, token, err = ls.Lookup(testCID)
	if err != nil || len(leases) != 1 {
		t.Fatalf("Got bad leases (%v): %v", leases, err)
	}

	secondNet := []net.IPNet{{
		IP:   net.ParseIP("2001:db8::2"),
		Mask: net.CIDRMask(128, 128),
	}}

	leases = append(leases, leasestorage.Lease{
		Elements: secondNet,
	})

	err = ls.Update(testCID, leases, token)
	if err != nil {
		t.Fatalf("Could not modify leases: %v", err)
	}

}

// bulkInsertLeases fills a LeaseStore with leases containing garbage data, generated by the passed callback
// It must only be used on an empty leasestore (it bypasses the normal interface)
func (lstore *LeaseStore) bulkInsertLeases(n int, generator func() leasestorage.Lease) {
	lstore.keyLock.Lock()
	defer lstore.keyLock.Unlock()
	for i := 1; i <= n; i++ {
		lstore.records[arbcid(rune(i))] = &storage{
			revision: uint64(i),
			leases:   []leasestorage.Lease{generator()},
		}
	}
	lstore.currentRev = uint64(n) + 1
}

func arbcid(n ...rune) leasestorage.ClientID {
	return leasestorage.ClientID{
		Variant: leasestorage.CidReservedExperimentalDoNotUse,
		Data:    string(n),
	}
}

func TestExpire(t *testing.T) {
	var ranExpirations int32

	ls := LeaseStore{
		currentRev: 123456,
		records: map[leasestorage.ClientID]*storage{
			arbcid('a'): {}, // Empty leases leftover
			arbcid('b'): {
				revision: 1,
				leases: []leasestorage.Lease{
					{}, // The zero lease, already expired
				},
			},
			arbcid('c'): {
				revision: 2,
				leases: []leasestorage.Lease{
					{ // One nonexpired lease
						Elements: []net.IPNet{{IP: net.ParseIP("2001:db8::1")}},
						Expire:   time.Date(3000, 1, 1, 0, 0, 0, 0, time.UTC),
					},
				},
			},
			arbcid('d'): {
				revision: 4,
				leases: []leasestorage.Lease{
					{}, // The zero lease, already expired
					{ // One nonexpired lease
						Elements: []net.IPNet{{IP: net.ParseIP("2001:db8::2")}},
						Expire:   time.Date(3000, 1, 2, 0, 0, 0, 0, time.UTC),
					},
					{}, // The zero lease, already expired
				},
			},
			arbcid('e'): {
				revision: 5,
				leases: []leasestorage.Lease{
					{
						Elements: []net.IPNet{{IP: net.ParseIP("2001:db8::3")}},
						ExpireAction: func([]net.IPNet, time.Time) {
							time.Sleep(100 * time.Millisecond)
							atomic.AddInt32(&ranExpirations, 1)
						},
					},
				},
			},
		},
	}
	actuallyCleaned, wg := ls.Expire(50)
	if atomic.LoadInt32(&ranExpirations) != 1 {
		t.Error("Expire did not finish running the ExpireActions before returning")
	}

	wg.Wait()

	if actuallyCleaned != 4 {
		t.Errorf("Did not clean the expected leases. Removed %d, expected 4", actuallyCleaned)
	}
}

func TestPartialExpire(t *testing.T) {
	ls := newLeaseStoreForTests()
	ls.bulkInsertLeases(200, func() leasestorage.Lease {
		// All inserted leases will be preexpired
		return leasestorage.Lease{}
	})

	actuallyCleaned, _ := ls.Expire(50)

	if actuallyCleaned != 50 {
		t.Error("Did not stop cleanly after the provided work amount")
	}
}

// Would be nice to have: at least a benchmark with concurrent access from multiple goroutines,
// both to disjoint sets of keys and to the same key
